<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Personal blog about low-level programming, security, and open-source software.">

  <title>
    
      T_PAGEFLT - Working with the NetBSD kernel
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="icon" type="image/png" href="/assets/favicon.png">

</head>


  <body>
    <nav class="nav">
      <div class="nav-container">
        <a href="/">
          <h2 class="nav-title">T_PAGEFLT</h2>
        </a>
        <ul>
          <li><a href="/">Posts</a></li>
          <li><a href="/about">About</a></li>
        </ul>
    </div>
  </nav>

    <main>
      <div class="post">
  <div class="post-info">
    
      <h1 class="post-title">Working with the NetBSD kernel</h1>
    

    
      <time datetime="2018-01-21">January 21, 2018</time>
    
  </div>
  <h2 id="overview">Overview</h2>

<p>When working on complex systems, such as OS kernels, your attention span and cognitive energy are too valuable to be wasted on inefficiencies pertaining to ancillary tasks. After experimenting with different environmental setups for kernel debugging, some of which were awkward and distracting from my main objectives, I have arrived to my current workflow, which is described here. This approach is mainly oriented towards security research and the study of kernel internals.</p>

<p>Before delving into the details, this is the general outline of my environment:</p>

<ul>
  <li>My host system runs Linux. My target system is a QEMU guest.</li>
  <li>I’m tracing and debugging on my host system by attaching GDB (with NetBSD x86-64 ABI support) to QEMU’s built-in GDB server.</li>
  <li>I work with NetBSD-current. All sources are built on my host system with the cross-compilation toolchain produced by <code class="highlighter-rouge">build.sh</code>.</li>
  <li>I use NFS to share the source tree and the build artifacts between the target and the host.</li>
  <li>I find IDEs awkward, so for codebase navigation I mainly rely on <code class="highlighter-rouge">vim</code>, <code class="highlighter-rouge">tmux</code> and <code class="highlighter-rouge">ctags</code>.</li>
  <li>For non-intrusive instrumentation, such as figuring out control flow, I’m using <code class="highlighter-rouge">dtrace</code>.</li>
</ul>

<h2 id="preparing-the-host-system">Preparing the host system</h2>

<p>For starters, there are few things that must be configured on the host system.</p>

<h3 id="qemu">QEMU</h3>

<p>Make sure your host system has a recent version of QEMU with support for the target architecture of your choice. The rest of this post will be dealing with x86-64 NetBSD guests. Also, make sure your system is configured for <a href="/basic-networking-with-qemu/" target="_blank">bridged-mode networking</a>, it will make debugging and working with QEMU guests much more convenient.</p>

<h3 id="gdb">GDB</h3>
<p>You will need a version of GDB with support for NetBSD x86_64 ABI. Most likely you won’t find it in your platform’s package repository, so you’ll have to compile it yourself. For example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ wget http://ftp.gnu.org/gnu/gdb/gdb-8.0.tar.xz
$ tar -xf gdb-8.0.tar.xz &amp;&amp; cd gdb-8.0
$ sudo mkdir -p /opt &amp;&amp; sudo chmod 755 /opt
$ ./configure --prefix=/opt --target=x86_64-netbsd
$ make -j4 &amp;&amp; sudo make install
</code></pre></div></div>

<p>Assuming you had all the required dependencies for the build, you should now have a GDB version with NetBSD x86-64 ABI support at <code class="highlighter-rouge">/opt/bin/x86_64-netbsd-gdb</code>. You might want to add this to your <code class="highlighter-rouge">$PATH</code> or symlink it to something more memorable.</p>

<h3 id="nfs-exports">NFS exports</h3>

<p>In order to avoid manually copying files around, it’s a good idea to set up a directory structure on the host system for the source tree, the toolchain and the build artifacts, and share it with the guest over NFS.</p>

<p>Here’s the directory structure that I use:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Code/netbsd-current			# The build root
~/Code/netbsd-current/destdir		# Userland binaries' location after compilation
~/Code/netbsd-current/objdir		# Build artifacts go here
~/Code/netbsd-current/releasedir	# Release files (created from `destdir`)
~/Code/netbsd-current/src		# Full source tree
~/Code/netbsd-current/tooldir		# Cross-compilation toolchain
</code></pre></div></div>

<p>Once the structure of the build root is created, export it, and restart your NFS server. In my case, I export <code class="highlighter-rouge">~/Code/netbsd-current</code>. This approach will keep everything neat and separate, without polluting the entire source tree with object files.</p>

<h2 id="building-netbsd-current">Building NetBSD-current</h2>

<h3 id="a-word-of-warning">A word of warning</h3>

<p>Now is a great time to familiarize yourself with the <a href="https://www.netbsd.org/docs/guide/en/chap-build.html#chap-build-environment-options" target="_blank">build.sh tool and its options</a>. Be especially carefull with the following options:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    -r          Remove contents of TOOLDIR and DESTDIR before building.
    -u          Set MKUPDATE=yes; do not run "make clean" first.
		Without this, everything is rebuilt, including the tools.
</code></pre></div></div>

<p>Chance are, you <strong>do not</strong> want to use these options once you’ve successfully built the cross-compilation toolchain and your entire userland, because building those takes time and there aren’t many good reasons to recompile them from scratch. Here’s what to expect:</p>

<ul>
  <li>On my desktop, running a quad-core Intel i5-3470 at 3.20GHz with 24GB of RAM and underlying directory structure residing on a SSD drive, the entire process took about 55 minutes. I was running <code class="highlighter-rouge">make</code> with  <code class="highlighter-rouge">-j12</code>, so the machine was quite busy.</li>
  <li>On an old Dell D630 laptop, running Intel Core 2 Duo T7500 at 2.20GHz with 4GB of RAM and a slow hard drive (5400RPM), the process took approximatelly 2.5 hours. I was running <code class="highlighter-rouge">make</code> with <code class="highlighter-rouge">-j4</code>. Based on the temperature alerts and CPU clock throttling messages, it was quite a struggle.</li>
</ul>

<h3 id="acquiring-the-sources">Acquiring the sources</h3>

<p>Install <code class="highlighter-rouge">cvs</code> if your haven’t done so already, configure <code class="highlighter-rouge">CVS_RSH</code> and <code class="highlighter-rouge">CVSROOT</code>, start the checkout process and grab a cup of coffee. At the moment of this writing, the entire source tree is around 2.6GB, so you’ll have to wait. I’m based in the Netherlands, so I use the closest CVS mirror, which is in France:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ export CVSROOT="anoncvs@anoncvs.fr.NetBSD.org:/pub/NetBSD-CVS"; export CVS_RSH="ssh"
$ cd ~/Code/netbsd-current
$ cvs checkout -PA src
</code></pre></div></div>

<h3 id="compiling-the-sources">Compiling the sources</h3>

<p>Once the checkout process is complete, you can start the lengthy process of building the toolchain and the system. I do not customize the kernel at this point, I build everything with the vanilla configuration and generate an ISO image from which I will provision my guest later on:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd ~/Code/netbsd-current/src
$ # Take a nap, grab a coffee, go on a holiday. This is going to take some time.
$ ./build.sh -m amd64 -T ../tooldir -D ../destdir \
	     -R ../releasedir -O ../objdir \
             -U -j6 release iso-image
</code></pre></div></div>

<p>Once the build has completed successfully, this is what you get:</p>
<ul>
  <li>Bootable ISO image under <code class="highlighter-rouge">releasedir/images/</code></li>
  <li>Installation sets under <code class="highlighter-rouge">releasedir/amd64/</code></li>
  <li>Cross-compilation toolchain under <code class="highlighter-rouge">toolchain/</code>, to be used by <code class="highlighter-rouge">build.sh</code> for builds performed on your host system. As long as you have the compiler set installed, you don’t need it for builds from within your guest.</li>
</ul>

<p>Depending on your system’s specs and whether you value disk space or computational time, you can also backup your <code class="highlighter-rouge">tooldir</code> somewhere outside the build root.</p>

<h2 id="preparing-the-guest-system">Preparing the guest system</h2>

<h3 id="provisioning-your-guest">Provisioning your guest</h3>

<p>You can use the ISO image generated earlier to build your target system:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir ~/vhd
$ qemu-img create ~/vhd/netbsd-current.img 10G
$ qemu-system-x86_64 -drive file=~/vhd/netbsd-current.img,format=raw \
                     -cdrom ~/Code/netbsd-current/releasedir/images/NetBSD-8.99.12-amd64.iso \
                     -device e1000,netdev=net0 -netdev bridge,id=net0,br=br0 -boot d \
                     -m 1024 -enable-kvm
</code></pre></div></div>

<p>I tend to install my guests roughly as follows:</p>

<ul>
  <li>Use CD/DVD media as the installation medium</li>
  <li>Install all the sets except “Games”, “X11 sets”, “Source and debug sets”</li>
  <li>Configure network to use DHCP</li>
  <li>Set the timezone</li>
  <li>Set the root password</li>
  <li>Enable <code class="highlighter-rouge">sshd</code>. Disable <code class="highlighter-rouge">cgd</code>, <code class="highlighter-rouge">raidframe</code></li>
  <li>Add a regular user, who is also part of the <code class="highlighter-rouge">wheel</code> group</li>
  <li>Drop to shell and power-down the VM instance</li>
</ul>

<p>Once the installation of the guest system is complete, all subsequent QEMU invocations should be in the following format:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ qemu-system-x86_64 -drive file=~/vhd/netbsd-current.img,format=raw \
                     -device e1000,netdev=net0 -netdev bridge,id=net0,br=br0 \
                     -m 1024 -enable-kvm -nographic -s
</code></pre></div></div>

<p>You might want an alias for that, or shell script wrapper.</p>

<p><em class="warning"><strong>Note:</strong> If you don’t see your guest’s console output in QEMU’s standard output, you’ll have to manually swtch the console device to <code class="highlighter-rouge">com0</code> in your <code class="highlighter-rouge">/boot.cfg</code> by adding <code class="highlighter-rouge">consdev com0;</code> to your first boot entry. Refer to <code class="highlighter-rouge">boot(8)</code> for more details.</em></p>

<h3 id="pkgin-and-nfs-shares">Pkgin and NFS shares</h3>

<p>The base system is quite… basic, so eventually you’ll want some packages. There’s the archaic <code class="highlighter-rouge">pkg_add</code>, but all the mentally stable cool kids nowadays use <code class="highlighter-rouge">pkgin</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ su -
# export PKG_URL="http://cdn.netbsd.org/pub/pkgsrc/packages/NetBSD/amd64/8.0_current/All"
# pkg_add "$PKG_URL/pkgin-0.9.4nb6.tgz"
# echo $PKG_URL &gt; /usr/pkg/etc/pkgin/repositories.conf
# pkgin update
</code></pre></div></div>

<p>You should also mount your host system’s NFS shares. First, ensure they are properly exported and visible from your guest:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ showmount -e [HOST IP ADDRESS]
</code></pre></div></div>

<p>Next, add the appropriate exports to <code class="highlighter-rouge">/etc/fstab</code> with <code class="highlighter-rouge">rw</code> permissions, run <code class="highlighter-rouge">mount -a</code>, and now you should be able to see the source tree and the build artifacts under the designated mount point on your guest. I tend to mount the build root within my guests at the same path as it is on my host system: <code class="highlighter-rouge">~/Code/netbsd-current/</code>.</p>

<h3 id="tailoring-the-kernel-for-debugging">Tailoring the kernel for debugging</h3>

<p>On your host system, make a copy of the GENERIC configuration:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd ~/Code/netbsd-current/src/sys/arch/amd64/conf
$ cp GENERIC QEMU
</code></pre></div></div>

<p>For source-level debugging and DTrace support you  should at the very least have the following options enabled:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>makeoptions     DEBUG="-g"      # compile full symbol table for CTF
options         KDTRACE_HOOKS   # kernel DTrace hooks
</code></pre></div></div>

<p>Neither the in-kernel debugger nor the in-kernel KGDB stub are of any use in this scenario, so make sure they’re disabled:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#options        DDB                     # in-kernel debugger
#options        DDB_COMMANDONENTER="bt" # execute command when ddb is entered
#options        DDB_ONPANIC=1           # see also sysctl(7): `ddb.onpanic'
#options        DDB_HISTORY_SIZE=512    # enable history editing in DDB
#options        KGDB                    # remote debugger
#options        KGDB_DEVNAME="\"com\"",KGDB_DEVADDR=0x3f8,KGDB_DEVRATE=9600
</code></pre></div></div>

<p>Once you’re happy with your kernel configuration, it needs to be built. I’m building everything on my host system, so naturally I’m using <code class="highlighter-rouge">build.sh</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd ~/Code/netbsd-current/src
$ ./build.sh -m amd64 -T ../tooldir -D ../destdir \
             -R ../releasedir -O ../objdir -U -u -j6 kernel=QEMU
</code></pre></div></div>

<p>Depending on your system’s specs and your kernel’s configuration, that shouldn’t take more than few minutes.</p>

<h3 id="installing-the-new-kernel">Installing the new kernel</h3>

<p>Once the build is complete, you can find the new kernel under <code class="highlighter-rouge">objdir/sys/arch/amd64/compile/QEMU/netbsd</code> in the shared directory tree. Jump into your guest system, backup the old kernel and install the new one:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># cp /netbsd /netbsd.old
# cp objdir/sys/arch/amd64/compile/QEMU/netbsd /netbsd
</code></pre></div></div>

<h3 id="configuring-dtrace">Configuring DTrace</h3>

<p>Add the following modules to <code class="highlighter-rouge">/etc/modules.conf</code> so you can use DTrace within your guest:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>solaris
dtrace
dtrace_sdt
dtrace_fbt
dtrace_lockstat
dtrace_profile
dtrace_syscall
</code></pre></div></div>

<p>Finally, reboot your guest. Assuming you didn’t mess up the kernel configuration, your guest’s kernel should be ready for debugging.</p>

<h2 id="debugging-the-guests-kernel">Debugging the guest’s kernel</h2>

<p>Now that the groundwork has been laid, you can simply load the kernel binary with the debugging symbols into your host’s <code class="highlighter-rouge">gdb</code>, and attach it to the live kernel on the QEMU instance:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd ~/Code/netbsd-current/objdir/sys/arch/amd64/compile/QEMU
$ /opt/bin/x86_64-netbsd-gdb ./netbsd.gdb
(gdb) target remote localhost:1234
Remote debugging using localhost:1234
0xffffffff8021d16e in x86_stihlt ()
(gdb) continue
</code></pre></div></div>

<p>Here are few useful GDB tips, if you haven’t used it much before:</p>

<ul>
  <li>You can interrupt the kernel execution at any time by invoking <code class="highlighter-rouge">Ctrl+C</code> in your debugger. You can continue the execution flow through <code class="highlighter-rouge">continue</code>/<code class="highlighter-rouge">c</code>.</li>
  <li>You can add breakpoints at most memory addresses, function names or line numbers within source files:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Adding breakpoints on function names:
(gdb) break sys_open
Breakpoint 1 at 0xffffffff804b267f:
file /home/dimitris/Code/netbsd-current/src/sys/kern/vfs_syscalls.c, line 1672.
(gdb) c
Continuing.
# Adding breakpoints on specific code lines within source files:
(gdb) break /home/dimitris/Code/netbsd-current/src/sys/kern/vfs_syscalls.c:1672
Breakpoint 2 at 0xffffffff804b267f:
file /home/dimitris/Code/netbsd-current/src/sys/kern/vfs_syscalls.c, line 1672.
(gdb)
</code></pre></div>    </div>
  </li>
  <li>You can single-step the execution using the <code class="highlighter-rouge">s</code> command</li>
  <li>You can look-up struct definitions:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) ptype struct mbuf
type = struct mbuf {
  struct m_hdr m_hdr;
  union {
      struct {...} MH;
      char M_databuf[456];
  } M_dat;
}
</code></pre></div>    </div>
  </li>
  <li>GDB can pretty-print internal kernel data structures
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) p uap
$4 = (const struct sys_open_args *) 0xffff800032da7f00
(gdb) p/x *uap
$5 = {path = {pad = 0x7f7fff9b46b0, le = {datum = 0x7f7fff9b46b0},
    be = {pad = 0xffff800032da7f00, datum = 0x7f7fff9b46b0}},
    flags = {pad = 0x0, le = {datum = 0x0},
    be = {pad = {0x0, 0x0, 0x0, 0x0}, datum = 0x0}}, 
    mode = {pad = 0x1b6, le = {datum = 0x1b6},
    be = {pad = {0xb6, 0x1, 0x0, 0x0}, datum = 0x0}}}
(gdb) p uap-&gt;path-&gt;le-&gt;datum
$6 = 0x7f7fff9b46b0 "/etc/pam.d/cron"
</code></pre></div>    </div>
  </li>
</ul>

<p>Describing GDB is beyond the scope of this article. Refer to the <a href="https://www.gnu.org/software/gdb/documentation/" target="_blank">official GDB documentation</a> to find out the many ways that GDB can make your life easier.</p>

<h2 id="additional-workflow-tips">Additional workflow tips</h2>

<ul>
  <li>Use <code class="highlighter-rouge">vim</code> and <code class="highlighter-rouge">ctags</code> instead of <code class="highlighter-rouge">grep</code> for symbol lookup. It’s much more efficient. Also learn how to use markers, buffers and windows within <code class="highlighter-rouge">vim</code>.</li>
  <li>To avoid namespace pollution, run <code class="highlighter-rouge">ctags -R .</code> in the root of your kernel (that is, in <code class="highlighter-rouge">src/sys/</code>) instead of the root of the entire source tree (<code class="highlighter-rouge">src/</code>).</li>
  <li>Add the following parameters to your <code class="highlighter-rouge">.vimrc</code>, so it can use <code class="highlighter-rouge">ctags</code> no matter how deep in the source tree you are:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set autochdir
set tags=tags;
</code></pre></div>    </div>
  </li>
  <li>Use <code class="highlighter-rouge">tmux</code> to avoid getting lost in all those open terminals.</li>
  <li>Learn some basic DTrace scripting with <code class="highlighter-rouge">fbt</code> and <code class="highlighter-rouge">syscall</code> providers. It will save you time and effort down the road.</li>
  <li>If you can’t find information on a specific aspect of the NetBSD kernel, check the documentation, maling lists and books written about the other BSD-derived systems. They all have “BSD” in their name for a reason.</li>
</ul>

<h2 id="further-reading">Further Reading:</h2>
<ul>
  <li><a href="https://www.netbsd.org/docs/guide/en/chap-fetch.html" target="_blank">NetBSD Documentation: Chapter 30. Obtaining the sources</a></li>
  <li><a href="https://www.netbsd.org/docs/guide/en/chap-build.html" target="_blank">NetBSD Documentation: Chapter 31. Crosscompiling NetBSD with build.sh</a></li>
  <li><a href="http://www.netbsd.org/docs/kernel/" target="_blank">NetBSD Documentation: Kernel</a></li>
  <li><a href="https://wiki.netbsd.org/tutorials/how_to_enable_and_run_dtrace/" target="_blank">NetBSD Tutorials: How to enable and run DTrace</a></li>
  <li><a href="https://wiki.freebsd.org/DTrace/Tutorial" target="_blank">FreeBSD Wiki: The DTrace One-Liner Tutorial</a></li>
  <li><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/" target="_blank">Debugging with GDB</a></li>
</ul>


 <div class="post-comment">
   You can comment <a target="_blank" href="mailto:t.pagef.lt@gmail.com?subject=[Working with the NetBSD kernel]" >here</a>.
 </div>

</div>

    </main>

    <footer>
      <span>Copyright &copy; <time datetime="2018">2018</time> Dimitris Karagkasidis</span>
      <span class="contact">
        <a href="mailto:t.pagef.lt@gmail.com">E-Mail</a>&nbsp;|&nbsp;
        <a href="https://twitter.com/t_pageflt" target="_blank">Twitter</a>&nbsp;|&nbsp;
        <a href="https://bsd.network/@t_pageflt" target="_blank">Mastodon</a>&nbsp;|&nbsp;
        <a href="https://github.com/pageflt" target="_blank">Github</a>&nbsp;|&nbsp;
        <a href="https://t.pagef.lt/assets/t_pageflt.asc" target="_blank">PGP</a>
      </span>
    </footer>
  </body>
</html>
